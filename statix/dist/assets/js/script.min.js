(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/ashleynolan/_projects/_sites/Freelance/meta-poetic/assets/src/js/helpers/log.js":[function(require,module,exports){
/**
 * Log.js - Lightweight wrapper for console.log
 *
 * Usage:
 * log('inside coolFunc', this, arguments);
 *
 * paulirish.com/2009/log-a-lightweight-wrapper-for-consolelog/
 */

window.log = function f() {
	log.history = log.history || [];
	log.history.push(arguments);
	if (this.console) {
		var args = arguments,
			newarr;
		try {
			args.callee = f.caller;
		} catch (e) {}
		newarr = [].slice.call(args);
		if (typeof console.log === 'object')  {
			log.apply.call(console.log, console, newarr);
		} else {
			console.log.apply(console, newarr);
		}
	}
};

},{}],"/Users/ashleynolan/_projects/_sites/Freelance/meta-poetic/assets/src/js/helpers/shims.js":[function(require,module,exports){
/*! 
Included shims: Array.forEach,Array.filter,Array.map,Function.bind,EventListener
*/

/*
    Array.prototype.forEach()
*/
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function(t, e) {
        var n, r;
        if (this == null) {
            throw new TypeError(" this is null or not defined");
        }
        // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
        var i = Object(this);
        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        var o = i.length >>> 0;
        // 4. If IsCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if (typeof t !== "function") {
            throw new TypeError(t + " is not a function");
        }
        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (e) {
            n = e;
        }
        // 6. Let k be 0
        r = 0;
        // 7. Repeat, while k < len
        while (r < o) {
            var a;
            // a. Let Pk be ToString(k).
            //   This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
            //   This step can be combined with c
            // c. If kPresent is true, then
            if (r in i) {
                // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
                a = i[r];
                // ii. Call the Call internal method of callback with T as the this value and
                // argument list containing kValue, k, and O.
                t.call(n, a, r, i);
            }
            // d. Increase k by 1.
            r++;
        }
    };
}

/*
    Array.prototype.filter()
*/
if (!Array.prototype.filter) {
    Array.prototype.filter = function(t) {
        "use strict";
        if (this === void 0 || this === null) throw new TypeError();
        var e = Object(this);
        var n = e.length >>> 0;
        if (typeof t !== "function") throw new TypeError();
        var r = [];
        var i = arguments.length >= 2 ? arguments[1] : void 0;
        for (var o = 0; o < n; o++) {
            if (o in e) {
                var a = e[o];
                // NOTE: Technically this should Object.defineProperty at
                //       the next index, as push can be affected by
                //       properties on Object.prototype and Array.prototype.
                //       But that method's new, and collisions should be
                //       rare, so use the more-compatible alternative.
                if (t.call(i, a, o, e)) r.push(a);
            }
        }
        return r;
    };
}

/*
   Array map patch
   ========================================================================== */
if (!("map" in Array.prototype)) {
    Array.prototype.map = function(t, e) {
        var n = this.length >>> 0, r = Array(n);
        for (var i = 0; i < n; i++) {
            if (i in this) {
                r[i] = t.call(e, this[i], i, this);
            }
        }
        return r;
    };
}

/*
    Function.prototype.bind()
*/
if (!Function.prototype.bind) {
    Function.prototype.bind = function(t) {
        if (typeof this !== "function") {
            // closest thing possible to the ECMAScript 5
            // internal IsCallable function
            throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
        }
        var e = Array.prototype.slice.call(arguments, 1), n = this, r = function() {}, i = function() {
            return n.apply(this instanceof r && t ? this : t, e.concat(Array.prototype.slice.call(arguments)));
        };
        r.prototype = this.prototype;
        i.prototype = new r();
        return i;
    };
}

// EventListener | MIT/GPL2 | https://github.com/jonathantneal/EventListener
this.Element && Element.prototype.attachEvent && !Element.prototype.addEventListener && function() {
    function t(t, e) {
        Window.prototype[t] = HTMLDocument.prototype[t] = Element.prototype[t] = e;
    }
    // add
    t("addEventListener", function(t, e) {
        var n = this, r = n.addEventListener.listeners = n.addEventListener.listeners || {}, i = r[t] = r[t] || [];
        // if no events exist, attach the listener
        if (!i.length) {
            n.attachEvent("on" + t, i.event = function(t) {
                var e = n.document && n.document.documentElement || n.documentElement || {
                    scrollLeft: 0,
                    scrollTop: 0
                };
                // polyfill w3c properties and methods
                t.currentTarget = n;
                t.pageX = t.clientX + e.scrollLeft;
                t.pageY = t.clientY + e.scrollTop;
                t.preventDefault = function() {
                    t.returnValue = false;
                };
                t.relatedTarget = t.fromElement || null;
                t.stopImmediatePropagation = function() {
                    l = false;
                    t.cancelBubble = true;
                };
                t.stopPropagation = function() {
                    t.cancelBubble = true;
                };
                t.target = t.srcElement || n;
                t.timeStamp = +new Date();
                // create an cached list of the master events list (to protect this loop from breaking when an event is removed)
                for (var r = 0, o = [].concat(i), a, l = true; l && (a = o[r]); ++r) {
                    // check to see if the cached event still exists in the master events list
                    for (var c = 0, s; s = i[c]; ++c) {
                        if (s == a) {
                            s.call(n, t);
                            break;
                        }
                    }
                }
            });
        }
        // add the event to the master event list
        i.push(e);
    });
    // remove
    t("removeEventListener", function(t, e) {
        var n = this, r = n.addEventListener.listeners = n.addEventListener.listeners || {}, i = r[t] = r[t] || [];
        // remove the newest matching event from the master event list
        for (var o = i.length - 1, a; a = i[o]; --o) {
            if (a == e) {
                i.splice(o, 1);
                break;
            }
        }
        // if no events exist, detach the listener
        if (!i.length && i.event) {
            n.detachEvent("on" + t, i.event);
        }
    });
    // dispatch
    t("dispatchEvent", function(t) {
        var e = this, n = t.type, r = e.addEventListener.listeners = e.addEventListener.listeners || {}, i = r[n] = r[n] || [];
        try {
            return e.fireEvent("on" + n, t);
        } catch (o) {
            if (i.event) {
                i.event(t);
            }
            return;
        }
    });
    // CustomEvent
    Object.defineProperty(Window.prototype, "CustomEvent", {
        get: function() {
            var t = this;
            return function e(n, r) {
                var i = t.document.createEventObject(), o;
                i.type = n;
                for (o in r) {
                    if (o == "cancelable") {
                        i.returnValue = !r.cancelable;
                    } else if (o == "bubbles") {
                        i.cancelBubble = !r.bubbles;
                    } else if (o == "detail") {
                        i.detail = r.detail;
                    }
                }
                return i;
            };
        }
    });
    // ready
    function e(t) {
        if (e.interval && document.body) {
            e.interval = clearInterval(e.interval);
            document.dispatchEvent(new CustomEvent("DOMContentLoaded"));
        }
    }
    e.interval = setInterval(e, 1);
    window.addEventListener("load", e);
}();

!this.CustomEvent && function() {
    // CustomEvent for browsers which don't natively support the Constructor method
    window.CustomEvent = function t(e, n) {
        var r;
        n = n || {
            bubbles: false,
            cancelable: false,
            detail: undefined
        };
        try {
            r = document.createEvent("CustomEvent");
            r.initCustomEvent(e, n.bubbles, n.cancelable, n.detail);
        } catch (i) {
            // for browsers which don't support CustomEvent at all, we use a regular event instead
            r = document.createEvent("Event");
            r.initEvent(e, n.bubbles, n.cancelable);
            r.detail = n.detail;
        }
        return r;
    };
}();
},{}],"/Users/ashleynolan/_projects/_sites/Freelance/meta-poetic/assets/src/js/modules/UI.js":[function(require,module,exports){
/*
	UI.js
	Example module to show how to include other JS files into you browserify build
*/

// dependencies for this module go here
// e.g. var $ = require('traversty')

module.exports = {
	init : function () {
		console.debug('KO.UI module is being initialised');
	}
};

},{}],"/Users/ashleynolan/_projects/_sites/Freelance/meta-poetic/assets/src/js/script.js":[function(require,module,exports){
/*	Author: Ashley Nolan
		Meta Poetic
*/

// --------------------------------------------- //
// DEFINE GLOBAL LIBS                            //
// --------------------------------------------- //
// Uncomment the line below to expose jQuery as a global object to the usual places
// window.jQuery = window.$ = require('../../../node_modules/jquery/dist/jquery.js');


// force compilation of global libs that don't return a value.
require("./helpers/log");
require("./helpers/shims");

//initialise KO object
var KO = {};

KO.Config = {

	init : function () {
		console.debug('Kickoff is running');

		// Example module include
		KO.UI = require('./modules/UI');
		KO.UI.init();
	}
};


KO.Config.init();

},{"./helpers/log":"/Users/ashleynolan/_projects/_sites/Freelance/meta-poetic/assets/src/js/helpers/log.js","./helpers/shims":"/Users/ashleynolan/_projects/_sites/Freelance/meta-poetic/assets/src/js/helpers/shims.js","./modules/UI":"/Users/ashleynolan/_projects/_sites/Freelance/meta-poetic/assets/src/js/modules/UI.js"}]},{},["/Users/ashleynolan/_projects/_sites/Freelance/meta-poetic/assets/src/js/script.js"])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhc3NldHMvc3JjL2pzL2hlbHBlcnMvbG9nLmpzIiwiYXNzZXRzL3NyYy9qcy9oZWxwZXJzL3NoaW1zLmpzIiwiYXNzZXRzL3NyYy9qcy9tb2R1bGVzL1VJLmpzIiwiYXNzZXRzL3NyYy9qcy9zY3JpcHQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxuICogTG9nLmpzIC0gTGlnaHR3ZWlnaHQgd3JhcHBlciBmb3IgY29uc29sZS5sb2dcbiAqXG4gKiBVc2FnZTpcbiAqIGxvZygnaW5zaWRlIGNvb2xGdW5jJywgdGhpcywgYXJndW1lbnRzKTtcbiAqXG4gKiBwYXVsaXJpc2guY29tLzIwMDkvbG9nLWEtbGlnaHR3ZWlnaHQtd3JhcHBlci1mb3ItY29uc29sZWxvZy9cbiAqL1xuXG53aW5kb3cubG9nID0gZnVuY3Rpb24gZigpIHtcblx0bG9nLmhpc3RvcnkgPSBsb2cuaGlzdG9yeSB8fCBbXTtcblx0bG9nLmhpc3RvcnkucHVzaChhcmd1bWVudHMpO1xuXHRpZiAodGhpcy5jb25zb2xlKSB7XG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRuZXdhcnI7XG5cdFx0dHJ5IHtcblx0XHRcdGFyZ3MuY2FsbGVlID0gZi5jYWxsZXI7XG5cdFx0fSBjYXRjaCAoZSkge31cblx0XHRuZXdhcnIgPSBbXS5zbGljZS5jYWxsKGFyZ3MpO1xuXHRcdGlmICh0eXBlb2YgY29uc29sZS5sb2cgPT09ICdvYmplY3QnKSAge1xuXHRcdFx0bG9nLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIG5ld2Fycik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIG5ld2Fycik7XG5cdFx0fVxuXHR9XG59O1xuIiwiLyohIFxuSW5jbHVkZWQgc2hpbXM6IEFycmF5LmZvckVhY2gsQXJyYXkuZmlsdGVyLEFycmF5Lm1hcCxGdW5jdGlvbi5iaW5kLEV2ZW50TGlzdGVuZXJcbiovXG5cbi8qXHJcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCgpXHJcbiovXG5pZiAoIUFycmF5LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgIHZhciBuLCByO1xuICAgICAgICBpZiAodGhpcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiIHRoaXMgaXMgbnVsbCBvciBub3QgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAxLiBMZXQgTyBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgVG9PYmplY3QgcGFzc2luZyB0aGUgfHRoaXN8IHZhbHVlIGFzIHRoZSBhcmd1bWVudC5cclxuICAgICAgICB2YXIgaSA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgLy8gMi4gTGV0IGxlblZhbHVlIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgR2V0IGludGVybmFsIG1ldGhvZCBvZiBPIHdpdGggdGhlIGFyZ3VtZW50IFwibGVuZ3RoXCIuXHJcbiAgICAgICAgLy8gMy4gTGV0IGxlbiBiZSBUb1VpbnQzMihsZW5WYWx1ZSkuXHJcbiAgICAgICAgdmFyIG8gPSBpLmxlbmd0aCA+Pj4gMDtcbiAgICAgICAgLy8gNC4gSWYgSXNDYWxsYWJsZShjYWxsYmFjaykgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cclxuICAgICAgICAvLyBTZWU6IGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuMTFcclxuICAgICAgICBpZiAodHlwZW9mIHQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcih0ICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNS4gSWYgdGhpc0FyZyB3YXMgc3VwcGxpZWQsIGxldCBUIGJlIHRoaXNBcmc7IGVsc2UgbGV0IFQgYmUgdW5kZWZpbmVkLlxyXG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBuID0gZTtcbiAgICAgICAgfVxuICAgICAgICAvLyA2LiBMZXQgayBiZSAwXHJcbiAgICAgICAgciA9IDA7XG4gICAgICAgIC8vIDcuIFJlcGVhdCwgd2hpbGUgayA8IGxlblxyXG4gICAgICAgIHdoaWxlIChyIDwgbykge1xuICAgICAgICAgICAgdmFyIGE7XG4gICAgICAgICAgICAvLyBhLiBMZXQgUGsgYmUgVG9TdHJpbmcoaykuXHJcbiAgICAgICAgICAgIC8vICAgVGhpcyBpcyBpbXBsaWNpdCBmb3IgTEhTIG9wZXJhbmRzIG9mIHRoZSBpbiBvcGVyYXRvclxyXG4gICAgICAgICAgICAvLyBiLiBMZXQga1ByZXNlbnQgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBIYXNQcm9wZXJ0eSBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIGFyZ3VtZW50IFBrLlxyXG4gICAgICAgICAgICAvLyAgIFRoaXMgc3RlcCBjYW4gYmUgY29tYmluZWQgd2l0aCBjXHJcbiAgICAgICAgICAgIC8vIGMuIElmIGtQcmVzZW50IGlzIHRydWUsIHRoZW5cclxuICAgICAgICAgICAgaWYgKHIgaW4gaSkge1xuICAgICAgICAgICAgICAgIC8vIGkuIExldCBrVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBHZXQgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCBhcmd1bWVudCBQay5cclxuICAgICAgICAgICAgICAgIGEgPSBpW3JdO1xuICAgICAgICAgICAgICAgIC8vIGlpLiBDYWxsIHRoZSBDYWxsIGludGVybmFsIG1ldGhvZCBvZiBjYWxsYmFjayB3aXRoIFQgYXMgdGhlIHRoaXMgdmFsdWUgYW5kXHJcbiAgICAgICAgICAgICAgICAvLyBhcmd1bWVudCBsaXN0IGNvbnRhaW5pbmcga1ZhbHVlLCBrLCBhbmQgTy5cclxuICAgICAgICAgICAgICAgIHQuY2FsbChuLCBhLCByLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGQuIEluY3JlYXNlIGsgYnkgMS5cclxuICAgICAgICAgICAgcisrO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLypcclxuICAgIEFycmF5LnByb3RvdHlwZS5maWx0ZXIoKVxyXG4qL1xuaWYgKCFBcnJheS5wcm90b3R5cGUuZmlsdGVyKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICB2YXIgZSA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIG4gPSBlLmxlbmd0aCA+Pj4gMDtcbiAgICAgICAgaWYgKHR5cGVvZiB0ICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDA7XG4gICAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgbjsgbysrKSB7XG4gICAgICAgICAgICBpZiAobyBpbiBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBlW29dO1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IFRlY2huaWNhbGx5IHRoaXMgc2hvdWxkIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBhdFxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgdGhlIG5leHQgaW5kZXgsIGFzIHB1c2ggY2FuIGJlIGFmZmVjdGVkIGJ5XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICBwcm9wZXJ0aWVzIG9uIE9iamVjdC5wcm90b3R5cGUgYW5kIEFycmF5LnByb3RvdHlwZS5cclxuICAgICAgICAgICAgICAgIC8vICAgICAgIEJ1dCB0aGF0IG1ldGhvZCdzIG5ldywgYW5kIGNvbGxpc2lvbnMgc2hvdWxkIGJlXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICByYXJlLCBzbyB1c2UgdGhlIG1vcmUtY29tcGF0aWJsZSBhbHRlcm5hdGl2ZS5cclxuICAgICAgICAgICAgICAgIGlmICh0LmNhbGwoaSwgYSwgbywgZSkpIHIucHVzaChhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xufVxuXG4vKlxyXG4gICBBcnJheSBtYXAgcGF0Y2hcclxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbmlmICghKFwibWFwXCIgaW4gQXJyYXkucHJvdG90eXBlKSkge1xuICAgIEFycmF5LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5sZW5ndGggPj4+IDAsIHIgPSBBcnJheShuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICByW2ldID0gdC5jYWxsKGUsIHRoaXNbaV0sIGksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG59XG5cbi8qXHJcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCgpXHJcbiovXG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAvLyBjbG9zZXN0IHRoaW5nIHBvc3NpYmxlIHRvIHRoZSBFQ01BU2NyaXB0IDVcclxuICAgICAgICAgICAgLy8gaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBuID0gdGhpcywgciA9IGZ1bmN0aW9uKCkge30sIGkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiByICYmIHQgPyB0aGlzIDogdCwgZS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9O1xuICAgICAgICByLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgICAgICBpLnByb3RvdHlwZSA9IG5ldyByKCk7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH07XG59XG5cbi8vIEV2ZW50TGlzdGVuZXIgfCBNSVQvR1BMMiB8IGh0dHBzOi8vZ2l0aHViLmNvbS9qb25hdGhhbnRuZWFsL0V2ZW50TGlzdGVuZXJcclxudGhpcy5FbGVtZW50ICYmIEVsZW1lbnQucHJvdG90eXBlLmF0dGFjaEV2ZW50ICYmICFFbGVtZW50LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyICYmIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIHQodCwgZSkge1xuICAgICAgICBXaW5kb3cucHJvdG90eXBlW3RdID0gSFRNTERvY3VtZW50LnByb3RvdHlwZVt0XSA9IEVsZW1lbnQucHJvdG90eXBlW3RdID0gZTtcbiAgICB9XG4gICAgLy8gYWRkXHJcbiAgICB0KFwiYWRkRXZlbnRMaXN0ZW5lclwiLCBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgIHZhciBuID0gdGhpcywgciA9IG4uYWRkRXZlbnRMaXN0ZW5lci5saXN0ZW5lcnMgPSBuLmFkZEV2ZW50TGlzdGVuZXIubGlzdGVuZXJzIHx8IHt9LCBpID0gclt0XSA9IHJbdF0gfHwgW107XG4gICAgICAgIC8vIGlmIG5vIGV2ZW50cyBleGlzdCwgYXR0YWNoIHRoZSBsaXN0ZW5lclxyXG4gICAgICAgIGlmICghaS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG4uYXR0YWNoRXZlbnQoXCJvblwiICsgdCwgaS5ldmVudCA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IG4uZG9jdW1lbnQgJiYgbi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgbi5kb2N1bWVudEVsZW1lbnQgfHwge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3A6IDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIHBvbHlmaWxsIHczYyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzXHJcbiAgICAgICAgICAgICAgICB0LmN1cnJlbnRUYXJnZXQgPSBuO1xuICAgICAgICAgICAgICAgIHQucGFnZVggPSB0LmNsaWVudFggKyBlLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgdC5wYWdlWSA9IHQuY2xpZW50WSArIGUuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIHQucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdC5yZWxhdGVkVGFyZ2V0ID0gdC5mcm9tRWxlbWVudCB8fCBudWxsO1xuICAgICAgICAgICAgICAgIHQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdC50YXJnZXQgPSB0LnNyY0VsZW1lbnQgfHwgbjtcbiAgICAgICAgICAgICAgICB0LnRpbWVTdGFtcCA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBjYWNoZWQgbGlzdCBvZiB0aGUgbWFzdGVyIGV2ZW50cyBsaXN0ICh0byBwcm90ZWN0IHRoaXMgbG9vcCBmcm9tIGJyZWFraW5nIHdoZW4gYW4gZXZlbnQgaXMgcmVtb3ZlZClcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSAwLCBvID0gW10uY29uY2F0KGkpLCBhLCBsID0gdHJ1ZTsgbCAmJiAoYSA9IG9bcl0pOyArK3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSBjYWNoZWQgZXZlbnQgc3RpbGwgZXhpc3RzIGluIHRoZSBtYXN0ZXIgZXZlbnRzIGxpc3RcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMCwgczsgcyA9IGlbY107ICsrYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT0gYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuY2FsbChuLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0aGUgZXZlbnQgdG8gdGhlIG1hc3RlciBldmVudCBsaXN0XHJcbiAgICAgICAgaS5wdXNoKGUpO1xuICAgIH0pO1xuICAgIC8vIHJlbW92ZVxyXG4gICAgdChcInJlbW92ZUV2ZW50TGlzdGVuZXJcIiwgZnVuY3Rpb24odCwgZSkge1xuICAgICAgICB2YXIgbiA9IHRoaXMsIHIgPSBuLmFkZEV2ZW50TGlzdGVuZXIubGlzdGVuZXJzID0gbi5hZGRFdmVudExpc3RlbmVyLmxpc3RlbmVycyB8fCB7fSwgaSA9IHJbdF0gPSByW3RdIHx8IFtdO1xuICAgICAgICAvLyByZW1vdmUgdGhlIG5ld2VzdCBtYXRjaGluZyBldmVudCBmcm9tIHRoZSBtYXN0ZXIgZXZlbnQgbGlzdFxyXG4gICAgICAgIGZvciAodmFyIG8gPSBpLmxlbmd0aCAtIDEsIGE7IGEgPSBpW29dOyAtLW8pIHtcbiAgICAgICAgICAgIGlmIChhID09IGUpIHtcbiAgICAgICAgICAgICAgICBpLnNwbGljZShvLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBubyBldmVudHMgZXhpc3QsIGRldGFjaCB0aGUgbGlzdGVuZXJcclxuICAgICAgICBpZiAoIWkubGVuZ3RoICYmIGkuZXZlbnQpIHtcbiAgICAgICAgICAgIG4uZGV0YWNoRXZlbnQoXCJvblwiICsgdCwgaS5ldmVudCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBkaXNwYXRjaFxyXG4gICAgdChcImRpc3BhdGNoRXZlbnRcIiwgZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMsIG4gPSB0LnR5cGUsIHIgPSBlLmFkZEV2ZW50TGlzdGVuZXIubGlzdGVuZXJzID0gZS5hZGRFdmVudExpc3RlbmVyLmxpc3RlbmVycyB8fCB7fSwgaSA9IHJbbl0gPSByW25dIHx8IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGUuZmlyZUV2ZW50KFwib25cIiArIG4sIHQpO1xuICAgICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgICAgICBpZiAoaS5ldmVudCkge1xuICAgICAgICAgICAgICAgIGkuZXZlbnQodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBDdXN0b21FdmVudFxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdpbmRvdy5wcm90b3R5cGUsIFwiQ3VzdG9tRXZlbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGUobiwgcikge1xuICAgICAgICAgICAgICAgIHZhciBpID0gdC5kb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpLCBvO1xuICAgICAgICAgICAgICAgIGkudHlwZSA9IG47XG4gICAgICAgICAgICAgICAgZm9yIChvIGluIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8gPT0gXCJjYW5jZWxhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkucmV0dXJuVmFsdWUgPSAhci5jYW5jZWxhYmxlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG8gPT0gXCJidWJibGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkuY2FuY2VsQnViYmxlID0gIXIuYnViYmxlcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvID09IFwiZGV0YWlsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkuZGV0YWlsID0gci5kZXRhaWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gcmVhZHlcclxuICAgIGZ1bmN0aW9uIGUodCkge1xuICAgICAgICBpZiAoZS5pbnRlcnZhbCAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICBlLmludGVydmFsID0gY2xlYXJJbnRlcnZhbChlLmludGVydmFsKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiRE9NQ29udGVudExvYWRlZFwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZS5pbnRlcnZhbCA9IHNldEludGVydmFsKGUsIDEpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBlKTtcbn0oKTtcblxuIXRoaXMuQ3VzdG9tRXZlbnQgJiYgZnVuY3Rpb24oKSB7XG4gICAgLy8gQ3VzdG9tRXZlbnQgZm9yIGJyb3dzZXJzIHdoaWNoIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgdGhlIENvbnN0cnVjdG9yIG1ldGhvZFxyXG4gICAgd2luZG93LkN1c3RvbUV2ZW50ID0gZnVuY3Rpb24gdChlLCBuKSB7XG4gICAgICAgIHZhciByO1xuICAgICAgICBuID0gbiB8fCB7XG4gICAgICAgICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZGV0YWlsOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHIgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgci5pbml0Q3VzdG9tRXZlbnQoZSwgbi5idWJibGVzLCBuLmNhbmNlbGFibGUsIG4uZGV0YWlsKTtcbiAgICAgICAgfSBjYXRjaCAoaSkge1xuICAgICAgICAgICAgLy8gZm9yIGJyb3dzZXJzIHdoaWNoIGRvbid0IHN1cHBvcnQgQ3VzdG9tRXZlbnQgYXQgYWxsLCB3ZSB1c2UgYSByZWd1bGFyIGV2ZW50IGluc3RlYWRcclxuICAgICAgICAgICAgciA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgICAgICAgICByLmluaXRFdmVudChlLCBuLmJ1YmJsZXMsIG4uY2FuY2VsYWJsZSk7XG4gICAgICAgICAgICByLmRldGFpbCA9IG4uZGV0YWlsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG59KCk7IiwiLypcblx0VUkuanNcblx0RXhhbXBsZSBtb2R1bGUgdG8gc2hvdyBob3cgdG8gaW5jbHVkZSBvdGhlciBKUyBmaWxlcyBpbnRvIHlvdSBicm93c2VyaWZ5IGJ1aWxkXG4qL1xuXG4vLyBkZXBlbmRlbmNpZXMgZm9yIHRoaXMgbW9kdWxlIGdvIGhlcmVcbi8vIGUuZy4gdmFyICQgPSByZXF1aXJlKCd0cmF2ZXJzdHknKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0aW5pdCA6IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmRlYnVnKCdLTy5VSSBtb2R1bGUgaXMgYmVpbmcgaW5pdGlhbGlzZWQnKTtcblx0fVxufTtcbiIsIi8qXHRBdXRob3I6IEFzaGxleSBOb2xhblxuXHRcdE1ldGEgUG9ldGljXG4qL1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbi8vIERFRklORSBHTE9CQUwgTElCUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG4vLyBVbmNvbW1lbnQgdGhlIGxpbmUgYmVsb3cgdG8gZXhwb3NlIGpRdWVyeSBhcyBhIGdsb2JhbCBvYmplY3QgdG8gdGhlIHVzdWFsIHBsYWNlc1xuLy8gd2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0gcmVxdWlyZSgnLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcycpO1xuXG5cbi8vIGZvcmNlIGNvbXBpbGF0aW9uIG9mIGdsb2JhbCBsaWJzIHRoYXQgZG9uJ3QgcmV0dXJuIGEgdmFsdWUuXG5yZXF1aXJlKFwiLi9oZWxwZXJzL2xvZ1wiKTtcbnJlcXVpcmUoXCIuL2hlbHBlcnMvc2hpbXNcIik7XG5cbi8vaW5pdGlhbGlzZSBLTyBvYmplY3RcbnZhciBLTyA9IHt9O1xuXG5LTy5Db25maWcgPSB7XG5cblx0aW5pdCA6IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmRlYnVnKCdLaWNrb2ZmIGlzIHJ1bm5pbmcnKTtcblxuXHRcdC8vIEV4YW1wbGUgbW9kdWxlIGluY2x1ZGVcblx0XHRLTy5VSSA9IHJlcXVpcmUoJy4vbW9kdWxlcy9VSScpO1xuXHRcdEtPLlVJLmluaXQoKTtcblx0fVxufTtcblxuXG5LTy5Db25maWcuaW5pdCgpO1xuIl19
